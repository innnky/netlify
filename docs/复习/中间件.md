# 中间件

## redis

+ 过期时间设置

  + 热点数据永不过期,避免缓存击穿
  + 增加随机时间防止缓存雪崩

+ setnx返回值0失败1成功

+ 使用set key  random-value nx ex seconds 实现分布式锁

  + 将加锁 过期命令编排到一起成为原子操作
  + 解锁 使用Lua脚本`if redis.call("get",KEYS[1]) == ARGV[1] then     return redis.call("del",KEYS[1]) else     return 0 end`

+ 持久化

  + RDB AOF
  + RDBsave方法已经弃用!使用BGSAVE
  + RDB
    + 优:紧凑压缩二进制,体积小恢复快
    + 缺:fork创建子线程 重量级操作不一频繁运行 无法实时
  + AOF
    + 优:文本协议格式,兼容性好,可读性好;   安全性好,everysec 做到每秒备份
    + 缺:文件大,读取慢
  + RDB-AOF混合

+ 高可用

  + 哨兵
    + 当节点不可达进行标记,若是主节点不可达则与其他哨兵协商选择新的主节点
    + 搭配主从模式
  + 集群
    + Redis集群采用虚拟槽分区来实现数据分片，它把所有的键根据哈希函数映射到0-16383整数槽内，计算公式为slot=CRC16(key)&16383，每一个节点负责维护一部分槽以及槽所映射的键值数据。

+ 主从同步

  + 全量复制(使用RDB)
  + 部分复制

+ 内存淘汰策略

  ![image-20220504202105254](https://cdn.jsdelivr.net/gh/innnky/images@master/uPic/image-20220504202105254.png)

+ 过期策略

  + 惰性删除:使用到的时候检查过期时间,过期则删除
  + 定期删除:每秒10次过期扫描

+ 三个问题

  ```
   缓存穿透：
  
  问题描述：
  
  客户端查询根本不存在的数据，使得请求直达存储层，导致其负载过大，甚至宕机。出现这种情况的原因，可能是业务层误将缓存和库中的数据删除了，也可能是有人恶意攻击，专门访问库中不存在的数据。
  
  解决方案：
  
      缓存空对象：存储层未命中后，仍然将空值存入缓存层，客户端再次访问数据时，缓存层会直接返回空值。
  
      布隆过滤器：将数据存入布隆过滤器，访问缓存之前以过滤器拦截，若请求的数据不存在则直接返回空值。
  
  缓存击穿：
  
  问题描述：
  
  一份热点数据，它的访问量非常大。在其缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。
  
  解决方案：
  
      永不过期：热点数据不设置过期时间，所以不会出现上述问题，这是“物理”上的永不过期。或者为每个数据设置逻辑过期时间，当发现该数据逻辑过期时，使用单独的线程重建缓存。
  
      加互斥锁：对数据的访问加互斥锁，当一个线程访问该数据时，其他线程只能等待。这个线程访问过后，缓存中的数据将被重建，届时其他线程就可以直接从缓存中取值。
  
  缓存雪崩：
  
  问题描述：
  
  在某一时刻，缓存层无法继续提供服务，导致所有的请求直达存储层，造成数据库宕机。可能是缓存中有大量数据同时过期，也可能是Redis节点发生故障，导致大量请求无法得到处理。
  
  解决方案：
  
      避免数据同时过期：设置过期时间时，附加一个随机数，避免大量的key同时过期。
  
      启用降级和熔断措施：在发生雪崩时，若应用访问的不是核心数据，则直接返回预定义信息/空值/错误信息。或者在发生雪崩时，对于访问缓存接口的请求，客户端并不会把请求发给Redis，而是直接返回。
  
      构建高可用的Redis服务：采用哨兵或集群模式，部署多个Redis实例，个别节点宕机，依然可以保持服务的整体可用。
  
  ```

+ 双写一致性

  + ​			先更新缓存，再更新数据库； 	
  + ​			先更新数据库，再更新缓存； 	
  + ​			先删除缓存，再更新数据库； 	
  + ​			先更新数据库，再删除缓存。 
  + 有效方案:	
    + 先更新数据库，再删除缓存。 
  + 先删除缓存，再更新数据库,延时一段时间再删除缓存 (延时双删)

+ 集群缺点:

  + key批量操作支持有限。如mset、mget
  + key事务操作支持有限
  + 不支持多数据库空间
  + 复制结构只支持一层(不支持树状)

+ hash数据结构

  + 数据量小采用ziplist(压缩列表)节省空间
  + 否则采用hashtable

+ zset数据节后

  + 数据量小采用ziplist
  + 否则采用skiplist:(效率堪比红黑树，却远比红黑树实现简单)

## MQ

+ mq作用?
  + 流量削峰
  + 解耦
  + 异步
+ 

