# MySQL

+ using(列名) 用于等值连接中简化join ... on A.xxx=B.xxx
+ 当分页查询 记录数很大时
  + 可以使用"延时关联"方式,使用有索引的列查出记录数之后再关联
  + 也可以转换为已知位置的查询,比如使用between..and...
  + 主要问题出在OFFSET上,它会扫描很多列然后丢弃掉,只使用LIMIT不会有问题
+ 行转列:group by + sum + 判断是否为那一列
  + ![image-20220501102248161](https://cdn.jsdelivr.net/gh/innnky/images@master/uPic/image-20220501102248161.png)
  + ![image-20220501102258814](https://cdn.jsdelivr.net/gh/innnky/images@master/uPic/image-20220501102258814.png) 
+ 预防sql注入:
  + 严格的参数校验
  + sql预编译
+ 将一张表数据更新到另一张表: 更新时做等值连接

## 索引

+ mysql在memory/heap引擎中支持hash索引
+ 优点
  + 唯一索引保证数据的唯一性
  + 加快查询速度
  + 加快连接速度
  + 加快分组速度
+ 分类:
  + 普通 唯一 主键
  + 单列 组合
  + 全文索引
  + 空间索引
+ 索引重建alter index indexname rebuild;(大于4层考虑重建)
+ 哈希索引
  + 等值查询更快
  + 无法进行范围查询
  + 不支持索引排序
  + 不支持模糊查询 左前缀匹配
  + 任何时候都需要回表查询
  + 不稳定, 性能不可预测, 哈希碰撞多时效率低


## 事务

+ 事务类型
  + 扁平事务
  + 带有保存点的扁平事务
  + 链事务
  + 嵌套事务
  + 分布式事务

## 锁

## 优化

+ 分页查询大量数据
+ having where 在where中尽量多筛掉一些,减少having中计算量
+ 使用索引 连接代替子查询提高查询速度
+ 慢查询:分析慢查询日志
  + 索引失效
  + 表结构设计问题
  + 分解关联查询(连接查询转换为多次单表查询,应用层做关联)
  + LIMIT
+ 插入:禁用索引 禁用检查
+ 插入数据效率影响因素:
  + 索引
  + 唯一性约束
  + 一次插入数据条数
  + 外键检查
  + 自动提交
+ 海量数据优化??

## 其他

+ MVCC?
+ 主从同步?

## Ali规范

### 建表

+ 与是否相关的以is_开头,使用tinyint存储 1是0否
+ 非负数必须为unsigned
+ 表名不使用复数形式
+ 
